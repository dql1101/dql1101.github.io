<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="面试,Java基础," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="应对Java开发工程师的面试题的总结">
<meta name="keywords" content="面试,Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题摘录-上">
<meta property="og:url" content="http://yoursite.com/2017/08/29/Java面试题摘录-上/index.html">
<meta property="og:site_name" content="香蕉还是那个皮">
<meta property="og:description" content="应对Java开发工程师的面试题的总结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-29T09:30:52.397Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试题摘录-上">
<meta name="twitter:description" content="应对Java开发工程师的面试题的总结">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/29/Java面试题摘录-上/"/>





  <title>Java面试题摘录-上 | 香蕉还是那个皮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">香蕉还是那个皮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/29/Java面试题摘录-上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我叫香蕉皮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="香蕉还是那个皮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面试题摘录-上</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-29T09:10:21+08:00">
                2017-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文章收藏/" itemprop="url" rel="index">
                    <span itemprop="name">技术文章收藏</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,167
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  应对Java开发工程师的面试题的总结
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>部分资料摘自：<a href="http://http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="external">骆昊</a> </p>
<p>感恩技术大牛对入行不久并想往高处前行的技术小白的无私分享<br><a id="more"></a></p>
<h2 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h2><ol>
<li><h3 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h3><ol>
<li><strong>抽象</strong>：将一类对象的共有属性抽离出来的过程；让我们只关乎对象有哪些属性和行为，而不用关注这些行为的具体细节是什么。</li>
<li><strong>继承</strong>：子类可以通过继承获得父类中对应的属性和方法。</li>
<li><strong>封装</strong>：将数据和操作数据的方法封装起来。</li>
<li><strong>多态</strong>：不同类型的子类对象可对同一行为作出不同的响应。</li>
</ol>
</li>
</ol>
</blockquote>
<ol>
<li><h3 id="int基本数据类型和Integer包装类型的区别？"><a href="#int基本数据类型和Integer包装类型的区别？" class="headerlink" title="int基本数据类型和Integer包装类型的区别？"></a>int基本数据类型和Integer包装类型的区别？</h3>在JDK5之后引入了自动装箱/拆箱机制，但是在使用过程中需要注意一下情况：<br>自动装箱的本质是如下代码：<figure class="highlight plain"><figcaption><span>static Integer valueOf(int i) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">    return new Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以如果我们的整型数据的值在IntegerCache.low(-128)到IntegerCache.high(127)之间就不会new新的Integer对象，直接从常量池中拿，如果不在这个范围内就会创建一个新的Integer对象。</p>
<ol>
<li><h3 id="内存中的栈-stack-，堆-heap-，静态区-static-area-的用法？"><a href="#内存中的栈-stack-，堆-heap-，静态区-static-area-的用法？" class="headerlink" title="内存中的栈(stack)，堆(heap)，静态区(static area)的用法？"></a>内存中的栈(stack)，堆(heap)，静态区(static area)的用法？</h3><p>通常我们定义一个基本数据类型的变量，一个对象的引用和一些函数的调用都保存在栈中；但是new朱来的对象一般都存储在堆空间中；而一些字符串和一些常量都是放在静态区中。例如<br><strong>String str = new String(“hello”);</strong><br>上面的语句中变量str放在栈中，new出来的字符串对象放在堆中，hello字面量放在静态区。（JAVA 6中使用了一项叫“逃逸分析”的技术，可以将一些局部对象放在栈上提升对象的操作性能）</p>
</li>
<li><h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><p>不对，如果两个对象互相equals，那么他们的hashcode应当是相同的。Java对于eqauls方法和hashCode方法是这样规定的：<strong>(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。</strong></p>
</li>
<li><h3 id="String-StringBuilder和StringBuffer的区别？"><a href="#String-StringBuilder和StringBuffer的区别？" class="headerlink" title="String,StringBuilder和StringBuffer的区别？"></a>String,StringBuilder和StringBuffer的区别？</h3><p>String是不可变字符串；StringBuilder和StringBuffer是可变字符串，二者的区别是<strong>StringBuilder是线程不安全的，StringBuffer是线程安全的</strong>。当操作少量字符串拼接的时候我们用+运算符进行连接；要连接的字符串很多的时候我们用StringBuilder或者StringBuffer的append方法进行拼接。</p>
</li>
<li><h3 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><ol>
<li>实现多态的时间不同，重载是编译时多态的体现，重写时运行时多态的体现；</li>
<li>重载发生在同一个类中，指同名方法拥有不同的参数列表，与返回值无关；重写发生在子父类中，子类重写的方法与父类被重写的方法拥有完全相同的返回类型和参数。</li>
<li>为什么不能以返回值区分重载？当我们调用某一个命名方法时，我们可能会直接调用而忽略其返回值，此时如果多个重名方法有不同的返回值，Java就无法判断我们需要调用的方法。  </li>
</ol>
</li>
<li><h3 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h3><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<ol>
<li><em>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</em></li>
<li><em>当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。</em></li>
<li><em>最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</em></li>
<li><em>采用委托机制来加载保证安全性，当加载一个类时，先往上层找—应用层—扩展层—核心类库，找到相同命名的类就直接加载。</em></li>
</ol>
</li>
<li><h3 id="抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同？"></a>抽象类（abstract class）和接口（interface）有什么异同？</h3><p> <strong>相同点</strong>：</p>
<ol>
<li>抽象类和接口都不能被实例化；</li>
<li><p>如果某个非抽象类继承某个抽象类或者实现了某个接口，那么需要对其中的抽象方法全部进行实现。 </p>
<p><strong>不同点</strong>：</p>
</li>
<li>抽象类中可以定义构造器，可以有抽象方法和非抽象方法；接口中不能不能有构造器，只能有抽象方法。</li>
<li>抽象类中的成员可以是任意权限；接口中的成员必须是public权限；</li>
<li>抽象类中可以定义成员变量；接口中定义的成员变量实际上都是常量。</li>
</ol>
</li>
<li><h3 id="静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h3><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p>
<pre><code> class Outer {

        class Inner {}

        public static void foo() { new Inner(); }

    public void bar() { new Inner(); }

       public static void main(String[] args) {
     new Inner();
  }
}
</code></pre><p>上面的代码中，Inner作为内部类依赖于Outer的实例化而创建；而在static静态方法中不存在this关键字，所以不能new Inner()；需要修改为new Outer().new Inner();</p>
</li>
<li><h3 id="Java中是否会存在内存泄漏？"><a href="#Java中是否会存在内存泄漏？" class="headerlink" title="Java中是否会存在内存泄漏？"></a>Java中是否会存在内存泄漏？</h3><p>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。</p>
</li>
<li><h3 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h3><ol>
<li>实现Cloneable接口并重写Object类中的clone()方法；</li>
<li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆（将对象内部包含的对象克隆过来成为一个新的对象）。</li>
</ol>
</li>
<li><h3 id="Java和JS的区别"><a href="#Java和JS的区别" class="headerlink" title="Java和JS的区别"></a>Java和JS的区别</h3><ol>
<li>Java是强变量类型的静态语言；JavaScript是弱变量类型的动态语言。</li>
<li>Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。</li>
</ol>
</li>
<li><h3 id="运行时异常与受检异常有何异同？"><a href="#运行时异常与受检异常有何异同？" class="headerlink" title="运行时异常与受检异常有何异同？"></a>运行时异常与受检异常有何异同？</h3><p>对运行时的几种处理方式：</p>
<ol>
<li>捕获</li>
<li>继续抛出</li>
<li>不处理</li>
</ol>
<p>对受检的几种处理方式：</p>
<ol>
<li>继续抛出，消极的方法，一直可以抛到java虚拟机来处理</li>
<li><p>用try…catch捕获</p>
<p>即对于受检异常必须处理，或者必须捕获或者必须抛出。</p>
</li>
</ol>
</li>
<li><p>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？<br>TreeSet要求存放的对象所属的类必须实现<strong>Comparable</strong>接口，该接口提供了比较元素的<br><strong>compareTo()</strong>方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现<br><strong>Comparable</strong>接口从而根据键对元素进行排序。<br>TreeSet比较排序的例子：</p>
<pre><code>    public class Student implements Comparable&lt;Student&gt; {
    private String name;// 姓名
    private int age;// 年龄

    public Student(String name, int age) {
    this.name = name;
    this.age = age;
    }

    @Override
    public String toString() {
    return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
    }

    @Override
    public int compareTo(Student o) {
    return this.age - o.age; // 比较年龄(年龄的升序)
    }

    import java.util.Set;
    import java.util.TreeSet;

    class Test01 {

    public static void main(String[] args) {
    Set&lt;Student&gt; set = new TreeSet&lt;&gt;();     
    set.add(new Student(&quot;Hao LUO&quot;, 33));
    set.add(new Student(&quot;XJ WANG&quot;, 32));
    set.add(new Student(&quot;Bruce LEE&quot;, 60));
    set.add(new Student(&quot;Bob YANG&quot;, 22));

    for(Student stu : set) {
        System.out.println(stu);
    }
     输出结果: 
    //      Student [name=Bob YANG, age=22]
    //      Student [name=XJ WANG, age=32]
    //      Student [name=Hao LUO, age=33]
    //      Student [name=Bruce LEE, age=60]
}
</code></pre><p>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则。例子：</p>
<pre><code>public static void main(String[] args) {
    List&lt;Student&gt; list = new ArrayList&lt;&gt;();
    list.add(new Student(&quot;Hao LUO&quot;, 33));
    list.add(new Student(&quot;XJ WANG&quot;, 32));
    list.add(new Student(&quot;Bruce LEE&quot;, 60));
    list.add(new Student(&quot;Bob YANG&quot;, 22));

// 通过sort方法的第二个参数传入一个Comparator接口对象
// 相当于是传入一个比较对象大小的算法到sort方法中
// 由于Java中没有函数指针、仿函数、委托这样的概念
// 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调
Collections.sort(list, new Comparator&lt;Student&gt; () {

    @Override
    public int compare(Student o1, Student o2) {
        return o1.getName().compareTo(o2.getName());    // 比较学生姓名
    }
});

for(Student stu : list) {
    System.out.println(stu);
}
     输出结果: 
//      Student [name=Bob YANG, age=22]
//      Student [name=XJ WANG, age=32]
//      Student [name=Hao LUO, age=33]
//      Student [name=Bruce LEE, age=60]
   }
</code></pre></li>
<li><h3 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h3><p><strong>sleep()</strong>方法是Thread类中的静态方法，这个方法会让线程暂停执行设定的时间，将执行交给其他线程，但是依然保留着对象的锁，当时间结束后会自动回复到就绪阶段，等待执行。</p>
<p> <strong>wait()</strong>方法是Object类中的方法，这个方法会使当前线程放弃对象的锁，进入对象等待池，只有调用了对象的notify()或者notifyAll()方法，才会唤醒进入等锁池，再次获得锁后进入就绪阶段，等待执行。</p>
</li>
<li><h3 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h3><ol>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li>
<li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ol>
</li>
<li><h3 id="编写多线程程序有几种实现方式？"><a href="#编写多线程程序有几种实现方式？" class="headerlink" title="编写多线程程序有几种实现方式？"></a>编写多线程程序有几种实现方式？</h3><ol>
<li>继承Thread类；</li>
<li>实现Runnable接口；</li>
<li><p>实现CallAble接口。</p>
<pre><code>class MyTask implements Callable&lt;Integer&gt; {
private int upperBounds;

public MyTask(int upperBounds) {
    this.upperBounds = upperBounds;
}

@Override
public Integer call() throws Exception {
    int sum = 0; 
    for(int i = 1; i &lt;= upperBounds; i++) {
        sum += i;
    }
    return sum;
}

}

class Test {

    public static void main(String[] args) throws Exception {
        List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
        ExecutorService service = Executors.newFixedThreadPool(10);
        for(int i = 0; i &lt; 10; i++) {
            list.add(service.submit(new MyTask((int) (Math.random() * 100))));
        }

        int sum = 0;
        for(Future&lt;Integer&gt; future : list) {
            // while(!future.isDone()) ;
            sum += future.get();
        }

        System.out.println(sum);
    }
}
</code></pre></li>
</ol>
</li>
<li><h3 id="什么是线程池（thread-pool）？"><a href="#什么是线程池（thread-pool）？" class="headerlink" title="什么是线程池（thread pool）？"></a>什么是线程池（thread pool）？</h3><ul>
<li><strong>newSingleThreadExecutor：创建一个单线程的线程池。</strong>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li><strong>newFixedThreadPool：创建固定大小的线程池。</strong>每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li><strong>newCachedThreadPool：创建一个可缓存的线程池。</strong>如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li><strong>newScheduledThreadPool：创建一个大小无限的线程池。</strong>此线程池支持定时以及周期性执行任务的需求。</li>
<li><strong>newSingleThreadExecutor：创建一个单线程的线程池。</strong>此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
</li>
<li><h3 id="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><a href="#XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？" class="headerlink" title="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"></a>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</h3><p>XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。<br>对XML的解析主要有<strong>DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML）</strong>。</p>
</li>
<li><h3 id="XML文件在开发中主要用在什么地方？"><a href="#XML文件在开发中主要用在什么地方？" class="headerlink" title="XML文件在开发中主要用在什么地方？"></a>XML文件在开发中主要用在什么地方？</h3><ol>
<li>XML可以用作数据交换，但是逐渐被JSON给替代了</li>
<li>XML可以作为我们的框架或者软件的配置文件。</li>
</ol>
</li>
<li><h3 id="Statement和PreparedStatement有什么区别？哪个性能更好？"><a href="#Statement和PreparedStatement有什么区别？哪个性能更好？" class="headerlink" title="Statement和PreparedStatement有什么区别？哪个性能更好？"></a>Statement和PreparedStatement有什么区别？哪个性能更好？</h3><ol>
<li>PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；</li>
<li>PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；</li>
<li>批量处理SQL语句或者频繁执行相同的查询时，PreparedStatement可以将编译优化后的SQL语句缓存起来，下次执行速度会很快。</li>
</ol>
</li>
<li><h3 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h3><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。</p>
</li>
<li><h3 id="事务的ACID是指什么？"><a href="#事务的ACID是指什么？" class="headerlink" title="事务的ACID是指什么？"></a>事务的ACID是指什么？</h3><ul>
<li>原子性（Atomic）：事务的一组操作要么全部成功，要么全部失败；</li>
<li>一致性（Consistent）：事务在执行前后，其系统状态是一致的；</li>
<li>隔离性（Isolated）：一个事务的运行结果不能影响另一个事务的运行；（三类读问题，脏读，不可重复读，幻读；两类写问题）</li>
<li>持久性（Durable）：事务完成后会被持久化，可通过日志和同步备份重建数据。</li>
</ul>
</li>
<li><h3 id="JDBC能否处理Blob和Clob？"><a href="#JDBC能否处理Blob和Clob？" class="headerlink" title="JDBC能否处理Blob和Clob？"></a>JDBC能否处理Blob和Clob？</h3><p>Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。</p>
</li>
<li><h3 id="简述一下面向对象的”六原则一法则”。"><a href="#简述一下面向对象的”六原则一法则”。" class="headerlink" title="简述一下面向对象的”六原则一法则”。"></a>简述一下面向对象的”六原则一法则”。</h3><ol>
<li>单一职责原则：一个类只做它该做的事情(高内聚的体现)；</li>
<li>开闭原则：实体对扩展开放，对修改关闭（抽象，封装可变性）；</li>
<li>依赖倒转原则：面向接口编程；</li>
<li>接口隔离原则：接口要小而专，尽量专注于某个功能；</li>
<li>合成聚合复用原则：优先使用聚合或合成关系复用代码；</li>
<li>里式替换原则：任何时候都可以用子类型替换掉父类型；</li>
<li>迪米特法则：低耦合的体现，一个对象应该对其他对象有尽可能少的了解。</li>
</ol>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          
            <a href="/tags/Java基础/" rel="tag"><i class="fa fa-tag"></i> Java基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/27/Oracle数据库/" rel="next" title="Oracle数据库">
                <i class="fa fa-chevron-left"></i> Oracle数据库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/30/我米社招Java网络面经/" rel="prev" title="我米社招Java网络面经">
                我米社招Java网络面经 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="我叫香蕉皮" />
          <p class="site-author-name" itemprop="name">我叫香蕉皮</p>
           
              <p class="site-description motion-element" itemprop="description">学习永无止境，技术深不见底；成不了大牛，也但愿不要荒废此生。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/dql1101" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/imxjp1101" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面试题"><span class="nav-number">1.</span> <span class="nav-text">Java面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的特征有哪些方面？"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象的特征有哪些方面？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int基本数据类型和Integer包装类型的区别？"><span class="nav-number">1.2.</span> <span class="nav-text">int基本数据类型和Integer包装类型的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存中的栈-stack-，堆-heap-，静态区-static-area-的用法？"><span class="nav-number">1.3.</span> <span class="nav-text">内存中的栈(stack)，堆(heap)，静态区(static area)的用法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><span class="nav-number">1.4.</span> <span class="nav-text">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-StringBuilder和StringBuffer的区别？"><span class="nav-number">1.5.</span> <span class="nav-text">String,StringBuilder和StringBuffer的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="nav-number">1.6.</span> <span class="nav-text">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述一下JVM加载class文件的原理机制？"><span class="nav-number">1.7.</span> <span class="nav-text">描述一下JVM加载class文件的原理机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类（abstract-class）和接口（interface）有什么异同？"><span class="nav-number">1.8.</span> <span class="nav-text">抽象类（abstract class）和接口（interface）有什么异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><span class="nav-number">1.9.</span> <span class="nav-text">静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中是否会存在内存泄漏？"><span class="nav-number">1.10.</span> <span class="nav-text">Java中是否会存在内存泄漏？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现对象克隆"><span class="nav-number">1.11.</span> <span class="nav-text">如何实现对象克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java和JS的区别"><span class="nav-number">1.12.</span> <span class="nav-text">Java和JS的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时异常与受检异常有何异同？"><span class="nav-number">1.13.</span> <span class="nav-text">运行时异常与受检异常有何异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><span class="nav-number">1.14.</span> <span class="nav-text">Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的sleep-方法和yield-方法有什么区别？"><span class="nav-number">1.15.</span> <span class="nav-text">线程的sleep()方法和yield()方法有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写多线程程序有几种实现方式？"><span class="nav-number">1.16.</span> <span class="nav-text">编写多线程程序有几种实现方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是线程池（thread-pool）？"><span class="nav-number">1.17.</span> <span class="nav-text">什么是线程池（thread pool）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><span class="nav-number">1.18.</span> <span class="nav-text">XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML文件在开发中主要用在什么地方？"><span class="nav-number">1.19.</span> <span class="nav-text">XML文件在开发中主要用在什么地方？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Statement和PreparedStatement有什么区别？哪个性能更好？"><span class="nav-number">1.20.</span> <span class="nav-text">Statement和PreparedStatement有什么区别？哪个性能更好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是DAO模式？"><span class="nav-number">1.21.</span> <span class="nav-text">什么是DAO模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的ACID是指什么？"><span class="nav-number">1.22.</span> <span class="nav-text">事务的ACID是指什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC能否处理Blob和Clob？"><span class="nav-number">1.23.</span> <span class="nav-text">JDBC能否处理Blob和Clob？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述一下面向对象的”六原则一法则”。"><span class="nav-number">1.24.</span> <span class="nav-text">简述一下面向对象的”六原则一法则”。</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我叫香蕉皮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共8.7k字</span>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
